{
    "0.6.6": {
        "fast-setup": {
            "name": "fast-setup",
            "alias": "Fast Setup",
            "description": "Here we will configure a project in Node.Js to use typescript and after run this example with <b>The Way</b>.",
            "fragments": [
                {
                    "name": "tsNode",
                    "alias": "Configuring Node.js with Typescript",
                    "description": "This section will describe how to setup your application to be ready to use the framework.",
                    "guides": [
                        {
                            "order": 0,
                            "description": "First of all we need to create a NodeJs project, so let's create a directory",
                            "code": "mkdir my-the-way-project",
                            "type": "markdown"
                        }, {
                            "order": 1,
                            "description": "Now we need to init the project with the command below",
                            "code": "npm init -y",
                            "type": "markdown"
                        }, {
                            "order": 2,
                            "description": "Let's add the typescript libraries and the nodemon(is way to watch the change files and recompile)\nNPM:",
                            "code": "npm i typescript nodemon ts-node @types/node --save-dev",
                            "type": "markdown"
                        }, {
                            "order": 3,
                            "description": "or Yarn",
                            "code": "yarn add typescript nodemon ts-node @types/node --dev",
                            "type": "markdown"
                        }, {
                            "order": 4,
                            "description": "Initializing your project to use Typescript",
                            "code": "./node_modules/.bin/tsc --init",
                            "type": "markdown"
                        }, {
                            "order": 5,
                            "description": "Now we need to create a directory structure, we suggest the follow structure:",
                            "code": "my-the-way-project ->\n   src ->\n      main ->\n         YOUR-PROJECT-DIRECTORIES-AND-FILES\n      test ->\n         YOUR-TESTS",
                            "type": "markdown"
                        }, {
                            "order": 5,
                            "description": "We need to update the tsconfig.json with the follow:\nNote: The outDir is the directory where the compiler will put the \"builded\" files. With the builded files we can execute with node.The include object tell do the compiler the files that needs to be compiled.",
                            "type": "json",
                            "code": "{\r\n    \"compileOnSave\": false,\r\n    \"compilerOptions\": {\r\n        \"baseUrl\": \".\/\",\r\n        \"downlevelIteration\": true,\r\n        \"outDir\": \".\/dist\/out-tsc\",\r\n        \"sourceMap\": true,\r\n        \"declaration\": false,\r\n        \"module\": \"esnext\",\r\n        \"moduleResolution\": \"node\",\r\n        \"emitDecoratorMetadata\": true,\r\n        \"experimentalDecorators\": true,\r\n        \"importHelpers\": true,\r\n        \"resolveJsonModule\": true,\r\n        \"target\": \"es2015\",\r\n        \"typeRoots\": [\r\n            \"node_modules\/@types\"\r\n        ],\r\n        \"lib\": [\r\n            \"es2018\",\r\n            \"dom\"\r\n        ]\r\n    }\r\n}\r\n  "
                        }, {
                            "order": 6,
                            "description": "Now we create a main.ts file at src/main/main.ts to test if everything is ok",
                            "type": "typescript",
                            "code": "export class Main {\r\n    constructor() {\r\n        console.log('Yeah')\r\n    }\r\n}\r\nnew Main();"
                        }, {
                            "order": 7,
                            "description": "Let's create a nodemon.json to watch your files",
                            "type": "json",
                            "code": "{\r\n    \"watch\": [\"src\"],\r\n    \"ext\": \"ts\",\r\n    \"ignore\": [\"src\/**\/*.spec.ts\", \"node_modules\/**\", \"src\/**\/*.js\"],\r\n    \"exec\": \"ts-node src/main/main.ts\"\r\n  }"
                        }, {
                            "order": 8,
                            "description": "Now in your project lets add some script's in to your package.json",
                            "type": "json",
                            "code": "\"scripts\": {\r\n    \"build\": \"tsc\",\r\n    \"serve\": \"nodemon --config nodemon.json --watch\"\r\n  }"
                        }, {
                            "order": 9,
                            "description": "Now we can execute an test if the main.ts are executed, to do that you only need to execute:<br> NPM:",
                            "code": "npm run serve",
                            "type": "markdown"
                        }, {
                            "order": 10,
                            "description": "Or Yarn:",
                            "code": "yarn serve",
                            "type": "markdown"
                        }
                    ]
                }, {
                    "name": "theWay",
                    "alias": "Running with The Way",
                    "description": "In this section we will configure and run an application with The Way",
                    "guides": [
                        {
                            "order": 0,
                            "description": "Let's install The Way and the RxJs<br> NPM:",
                            "code": "npm i @nihasoft/the-way rxjs",
                            "type": "markdown"
                        }, {
                            "order": 1,
                            "description": "Yarn:",
                            "code": "yarn add @nihasoft/the-way rxjs",
                            "type": "markdown"
                        }, {
                            "order": 2,
                            "description": "Let's adjust your main class to extends TheWayApplication and decorate with @Application()",
                            "code": "import { TheWayApplication, Application } from '@nihasoft\/the-way'\r\n\r\n@Application()\r\nexport class Main extends TheWayApplication {\r\n    public start(): void {\r\n        console.log('Yeah, now I\\'m The Way application');\r\n    }\r\n}",
                            "type": "typescript"
                        }
                    ]
                }, {
                    "name": "injection-example",
                    "alias": "Injection example",
                    "description": "Now we create a class to be injected and test if it's work",
                    "guides": [
                        {
                            "order": 0,
                            "description": "Creating a class to inject",
                            "code": "export class InjectionExample {\r\n    public helloWorld() {\r\n        console.log('hello world');\r\n    }\r\n}"
                        }, {
                            "order": 1,
                            "description": "Injecting the created class into the main",
                            "code": "import { TheWayApplication, Application, Inject } from '@nihasoft\/the-way'\r\nimport { InjectionExample } from '.\/injection-example';\r\n\r\n@Application()\r\nexport class Main extends TheWayApplication {\r\n\r\n    @Inject() injectionExample: InjectionExample;\r\n\r\n    public start(): void {\r\n        this.injectionExample.helloWorld();\r\n    }\r\n}"
                        }
                    ]
                }, {
                    "name": "rest-example",
                    "alias": "Rest Example",
                    "description": "Now we create a REST class with some methods to be executed",
                    "guides": [
                        {
                            "order": 0,
                            "description": "Creating REST class with some methods",
                            "code": "import { Get } from '@nihasoft\/the-way';\r\nimport { Observable, of } from 'rxjs';\r\n\r\nexport class HeroRest{\r\n    @Get('\/hero')\r\n    public getHero(): Observable<{id: number, name: string, power: number}> {\r\n        return of({\r\n            id: 10,\r\n            name: 'Batman',\r\n            power: 10000\r\n        })\r\n    }\r\n}"
                        }, {
                            "order": 1,
                            "description": "Injecting the created class into the main",
                            "code": "import { TheWayApplication, Application, Inject } from '@nihasoft\/the-way'\r\nimport { InjectionExample } from '.\/injection-example';\r\nimport { HeroRest } from '.\/hero.rest';\r\n\r\n@Application()\r\nexport class Main extends TheWayApplication {\r\n\r\n    @Inject() injectionExample: InjectionExample;\r\n    @Inject() heroRest: HeroRest;\r\n\r\n    public start(): void {\r\n        this.injectionExample.helloWorld();\r\n    }\r\n}"
                        }
                    ]
                }
            ]
        },
        "core": {
            "name": "core",
            "alias": "CORE",
            "description": "The class CORE is the heart and mind of this framework. It's is responsable to build the dependency tree, inject, configure and destroy.<br>Also, you can watch when everything is ready, when every is destroyed =(, you can get an instance by name, you can get all instances that are injected and you can destroy.",
            "fragments": [
                {
                    "name": "ready",
                    "alias": "When Is Ready",
                    "description": "We provided an observable to tell you when everything is ready(all configurations are done, all injections are done, all overridden are done), to use this you only need to get the core instance and call the method: whenReady.<br> <b>Note:</b> the initial value of this observable is false.",
                    "guides": [
                        {
                            "order": 0,
                            "description": "<br><b>Using the method whenReady</b>",
                            "code": "CORE.getCoreInstance().whenReady().subscribe((ready: boolean) => {\r\n    if(ready) {\r\n        console.log('Hi, I\\'m ready.');\r\n    }\r\n});",
                            "type": "typescript"
                        }
                    ]
                }, {
                    "name": "the-way-application",
                    "alias": "The Way Application",
                    "description": "When you want to use this framework, you must provide a class decorated with @Application and extension of TheWayApplication.",
                    "guides": [
                        {
                            "order": 0,
                            "description": "When your class extends the TheWayApplication, you must implement the method <b>start(): void</b>. The method start will be called when the application(core) is ready. <br>The code below is an example of a class that extends TheWayApplication and is decorated with @Application.",
                            "code": "import { TheWayApplication, Application, Inject, CORE} from '@nihasoft\/the-way'\r\nimport { InjectionExample } from '.\/injection-example';\r\nimport { HeroRest} from '.\/hero.rest';\r\n\r\n@Application()\r\nexport class Main extends TheWayApplication {\r\n\r\n    @Inject() injectionExample: InjectionExample;\r\n    @Inject() heroRest: HeroRest;\r\n\r\n    constructor() {\r\n        super();\r\n        CORE.getCoreInstance().whenReady().subscribe((ready: boolean) => {\r\n            if(ready) {\r\n                console.log('Hi, I\\'m ready.');\r\n            }\r\n        });\r\n    }\r\n\r\n    public start(): void {\r\n        this.injectionExample.helloWorld();\r\n    }\r\n}",
                            "type": "typescript"
                        }
                    ]
                }, {
                    "name": "application",
                    "alias": "Get Instance Of The Application",
                    "description": "When the application is fully loaded, you can get the Application Instance. This instace is the class that extended the TheWayApplication and is decorated with @Application.",
                    "guides": [
                        {
                            "order": 0,
                            "description": "Getting the Application Instance:",
                            "code": "CORE.getCoreInstance().getApplicationInstance();",
                            "type": "typescript"
                        }
                    ]
                }, {
                    "name": "instance-by-name",
                    "alias": "Get Instance By Name",
                    "description": "When you want to inject a class in another class the default way to do that is using the <b>@Inject</b> decorator. But sometimes we don't want to inject a class but we want to get the instance at runtime and use this. So, we provided a way to get a instance at runtime. <br><b>Note:</b> You only can get an instance that is decorated with @Service, @Configuraation or is an injection of another class.",
                    "guides": [
                        {
                            "order": 0,
                            "description": "To get an instance you need to use the method getInstanceByName<T>(instanceName: string), where T is the class and instanceName is the name that class you want to get.<br><b>Note:</b> The type or class is optional.<br>See the code below:",
                            "code": "CORE.getCoreInstance().getInstanceByName<SecurityService>('SecurityService');",
                            "type": "typescript"
                        }
                    ]
                }, {
                    "name": "destroy",
                    "alias": "Destroy",
                    "description": "You can destroy everything. With this method's all the configurations done, the http server builded and the injections will be destroyed. The classes that extends AbstractConfiguration or extends the Destroyable class, will be destroyed when the method destroy of the core is called.<br><b>Note:</b>yours classes  that extends AbstractConfigurration or Destroyable MUST implement correctly the method destroy(): Observable<boolean> emitting the value true when all the conections or things that must be destroyed are destroyed.",
                    "guides": [
                        {
                            "order": 0,
                            "description": "Calling the destroy method of a core instance",
                            "code": "const core = CORE.getCoreInstance();\r\ncore.destroy().subscribe((destroyed: boolean) => {\r\n    if (destroyed) {\r\n        console.log('DIED: 1');\r\n    }\r\n});",
                            "type": "typescript"
                        }, {
                            "order": 1,
                            "description": "Calling the destroy method of a core instance and watching the CORE.destroyed$",
                            "code": "const core = CORE.getCoreInstance();\r\ncore.destroy().subscribe();\r\nCORE.destroyed$.subscribe((destroyed: boolean) => {\r\n    if (destroyed) {\r\n        console.log('DIED: 2');\r\n    }\r\n});",
                            "type": "typescript"
                        }, {
                            "order": 2,
                            "description": "A destroyable class",
                            "code": "import { AbstractConfiguration, Configuration } from '@nihasoft\/the-way';\r\n\r\nimport { Observable, timer } from 'rxjs';\r\nimport { map } from 'rxjs\/operators';\r\n\r\n@Configuration()\r\nexport class DestructableConfiguration extends AbstractConfiguration {\r\n    public destroy(): Observable<boolean> {\r\n        return timer(1000).pipe(\r\n            map(() => {\r\n                console.log('I loved this world to much...');\r\n                return true;\r\n            })\r\n        );\r\n    }\r\n}",
                            "type": "typescript"
                        }
                    ]
                }
            ]
        },
        "rest": {
            "name": "rest",
            "alias": "Rest & decorators",
            "description": "This framework provide for your application a loot of decorators to user REST concepts more easealy. You can map a path with the decorators like @Post, @Get, @Put, @Delete and others. You can inject into your method parameters from the request or context of the request using the decoratos like: @PathParam, @BodyParam, @QueryParam, @Header, @Claims, @Request and @Response. Also, you can verify if the user has a token and if  has a certain profile inside the token claims of the user, with that you can enable or reject requests with safetily. You can change some behavior like the security service providing your custom security service.",
            "fragments": [
                {
                    "name": "http-server",
                    "alias": "Http Server",
                    "description": "To use the REST decorators your application must enable the http server by application parameters. The default behavior will enable http server. When the http server is enabled you can use the REST decorators",
                    "guides": [
                        {
                            "order": 0,
                            "description": "Creating an interface to represent the Hero",
                            "code": "export interface HeroModel {\r\n    id: number;\r\n    name: string;\r\n    power: number;\r\n}",
                            "type": "typescript"
                        }, {
                            "order": 1,
                            "description": "Creating a REST class",
                            "code": "import { Get, BodyParam, Post, BadRequestException } from '@nihasoft\/the-way';\r\nimport { Observable, of } from 'rxjs';\r\nimport { HeroModel } from '.\/hero.model';\r\n\r\nexport class HeroRest {\r\n    heroes: Array<HeroModel> = [{\r\n        id: 10,\r\n        name: 'Batman',\r\n        power: 10000\r\n    }];\r\n    @Get('\/heroes')\r\n    public getHeroes(): Observable<Array<HeroModel>> {\r\n        return of(this.heroes);\r\n    }\r\n}",
                            "type": "typescript"
                        }, {
                            "order": 2,
                            "description": "Injecting your REST class into your main. <br><b>Note:</b> You can create a class that inject all yours class rest and inject only this class into your main.",
                            "code": "import { TheWayApplication, Application, Inject } from '@nihasoft\/the-way';\r\nimport { HeroRest} from '.\/hero.rest';\r\n\r\n@Application()\r\nexport class Main extends TheWayApplication {\r\n\r\n    @Inject() heroRest: HeroRest;\r\n\r\n    public start(): void {\r\n        console.log('I\\'m ready.');\r\n    }\r\n}",
                            "type": "typescript"
                        }
                    ]
                }, {
                    "name": "user-rest",
                    "alias": "User and token to safe endpoints",
                    "description": "Below we will create an endpoint to simulate a sign in process. We will generate a JWT token to be used in endpoints where needs a user logged and the user must contain a certain profile.",
                    "guides": [
                        {
                            "order": 0,
                            "description": "Creating a rest class to generate a token",
                            "code": "import { Post, BodyParam, UnauthorizedException, Inject, SecurityService } from '@nihasoft\/the-way';\r\nimport { Observable, of } from 'rxjs';\r\n\r\nexport class UserRest {\r\n    @Inject() securityService: SecurityService;\r\n\r\n    user: {\r\n        username: 'anakin',\r\n        password: 'I\\'m the force',\r\n        profiles: ['master', 'jedi']\r\n    }\r\n    @Post('\/sign\/in')\r\n    public signIn(@BodyParam signInForm: any): Observable<string> {\r\n        if (this.user.username === signInForm.username && this.user.password === signInForm.password) {\r\n            return of(this.securityService.generateToken({\r\n                username: this.user.username,\r\n                profiles: this.user.profiles\r\n            }));\r\n        } else {\r\n            throw new UnauthorizedException('Username or password is incorrect.');\r\n        }\r\n    }\r\n}",
                            "type": "typescript"
                        }, {
                            "order": 1,
                            "description": "Injecting the user rest into the main",
                            "code": "import { TheWayApplication, Application, Inject } from '@nihasoft\/the-way';\r\nimport { HeroRest} from '.\/hero.rest';\r\nimport { UserRest } from '.\/user.rest';\r\n\r\n@Application()\r\nexport class Main extends TheWayApplication {\r\n\r\n    @Inject() heroRest: HeroRest;\r\n    @Inject() userRest: UserRest;\r\n\r\n    public start(): void {\r\n        console.log('I\\'m ready.');\r\n    }\r\n}",
                            "type": "typescript"
                        }
                    ]
                }, {
                    "name": "get",
                    "alias": "@Get",
                    "description": "With this decorator you can map and use the http get method.",
                    "guides": [
                        {
                            "order": 0,
                            "description": "Get example",
                            "code": "heroes: Array<HeroModel> = [{\r\n    id: 10,\r\n    name: 'Batman',\r\n    power: 10000\r\n}];\r\n@Get('\/heroes')\r\npublic getHeroes(): Observable<Array<HeroModel>> {\r\n    return of(this.heroes);\r\n}",
                            "type": "typescript"
                        }, {
                            "order": 1,
                            "description": "Get example with @PathParam",
                            "code": "@Get('\/hero\/{id}')\r\npublic getHero(@PathParam('id') id: number): Observable<HeroModel> {\r\n    const hero = this.getHeroById(id);\r\n    if (!hero) {\r\n        throw new NotFoundException('Hero not found');\r\n    }\r\n    return of(hero);\r\n}\r\npublic getHeroById(id: number): HeroModel {\r\n    return this.heroes.find((hero:HeroModel) => hero.id === id)\r\n}",
                            "type": "typescript"
                        }, {
                            "order": 2,
                            "description": "Get example with @QueryParam",
                            "code": "@Get('\/hero')\r\npublic getHeroesWithQuery(@QueryParam query: {ids: Array<number>}): Observable<Array<HeroModel>> {\r\n    const heroes: Array<HeroModel> = [];\r\n    for (const id of query.ids) {\r\n        const hero: HeroModel = this.getHeroById(id);\r\n        if (hero) {\r\n            heroes.push(hero);\r\n        }\r\n    }\r\n    return of(heroes);\r\n}",
                            "type": "typescript"
                        }
                    ]
                }, {
                    "name": "post",
                    "alias": "@Post",
                    "description": "With this decorator you can map and use the http post method. ",
                    "guides": [
                        {
                            "order": 0,
                            "description": "Post example with @BodyParam injection (inside of the HeroRest).",
                            "code": "@Post('\/hero')\r\npublic createHero(@BodyParam newHero: HeroModel): Observable<HeroModel> {\r\n    if (this.hasHero(newHero)) {\r\n        throw new BadRequestException('The hero is registered.');\r\n    }\r\n    this.heroes.push(newHero);\r\n    return of(newHero);\r\n}\r\npublic hasHero(newHero: HeroModel): boolean {\r\n    return this.getHeroById(newHero.id) !== null;\r\n}",
                            "type": "typescript"
                        }
                    ]
                }, {
                    "name": "delete",
                    "alias": "@Delete",
                    "description": "With this decorator you can map and use the http delete method.",
                    "guides": [
                        {
                            "order": 0,
                            "description": "In the code below we created an endpoint in the HeroRest where must has a logged user and that user must contain the profile 'master'. So, we only can delete a hero if the user is logged(true) and the user has the profile 'master' (['master']).<br><b>Note:</b> You can pass more than one profile in the third parameter and when the user has one of the profiles, the rest will be executed.",
                            "code": "@Delete('\/hero\/{id}', true, ['master'])\r\npublic deleteHero(@PathParam('id') id: number): Observable<boolean> {\r\n    let hero: HeroModel;\r\n    for (let i = 0; i < this.heroes.length; i++) {\r\n        if (this.heroes[i].id === id) {\r\n            hero = this.heroes.splice(i, 1)[0];\r\n            break;\r\n        }\r\n    }\r\n    if (!hero) {\r\n        throw new BadRequestException('The hero not exists.');\r\n    }\r\n    return of(true);\r\n}",
                            "type": "typescript"
                        }
                    ]
                }, {
                    "name": "put",
                    "alias": "@Put",
                    "description": "With this decorator you can map and use the http put method.",
                    "guides": [
                        {
                            "order": 0,
                            "description": "In the code below we created an endpoint in the HeroRest where must has a logged user to update a hero.",
                            "code": "@Put('\/hero', true)\r\npublic updateHero(@BodyParam updateHero: HeroModel): Observable<HeroModel> {\r\n    const hero = this.getHeroById(updateHero.id);\r\n    if (!hero) {\r\n        throw new BadRequestException('The hero not exists.');\r\n    }\r\n    hero.name = updateHero.name;\r\n    hero.power = updateHero.power;\r\n    return of(hero);\r\n}",
                            "type": "typescript"
                        }
                    ]
                },{
                    "name": "other-decorators",
                    "alias": "Argument REST decorators",
                    "description": "The sections below will describe all the decorations that can be injected as parameter into your rest methods.<br><b>Note:</b> Some scenarios you can put more than one argument rest decorator.",
                    "guides": [
                        {
                            "order": 0,
                            "description": "<b>@QueryParam</b> is responsible to bring the query parameters passed in the url to an object. To use this decorator you only need to put into your method an argument with @QueryParam."
                        }, {
                            "order": 1,
                            "description": "<b>@BodyParam</b> is responsible to bring the body passed in the request. To use this decorator you only need to put into your method an argument with @BodyParam."
                        }, {
                            "order": 2,
                            "description": "<b>@PathParam</b> is an argument passed in the url where sometimes is used to pass an id or an identifier. To use this decorator you must provide in your method an argument with @PathParam('VARIABLE_NAME') where VARIABLE_NAME is the parameter from url."
                        }, {
                            "order": 3,
                            "description": "<b>@Claims</b> is an argument from the token. When you generate the token you pass some things like user profiles, username and others, with this decorator you can retrieve that informations from the token. To use this it's very simple you only need to put an argument with @Claims"
                        }, {
                            "order": 4,
                            "description": "<b>@Request</b> is the current request. To use this you only need to put an argument with @Request."
                        }, {
                            "order": 5,
                            "description": "<b>@Response</b> is the current response. You can send the response with that. To use this you only need to put an argument with @Response."
                        }, {
                            "order": 6,
                            "description": "<b>@Header</b> is the header of the request. To use this you only need to put an argument with @Header."
                        }
                    ]
                }
            ]
        },
        "application-decorator": {
            "name": "application-decorator",
            "alias": "Application Decorator",
            "description": "In this section we will describe the applications decorators like: @Inject, @Configure and others.",
            "fragments": [
                {
                    "name": "application",
                    "alias": "@Application",
                    "description": "Is the core decorator. When you want to use this framework you must supply a class that is decorated with this an extends the TheWayApplication. This decorator has a json parameter, in this json parameter you can set automatic and custom, the sections below will explain this behaviors.",
                    "guides": [
                        {
                            "order": 0,
                            "description": "<b>Default Class</b>: A class decorated with @Application with the default behavior.",
                            "code": "import { TheWayApplication, Application } from '@nihasoft\/the-way';\r\n\r\n@Application()\r\nexport class Main extends TheWayApplication {\r\n\r\n    public start(): void {\r\n        console.log('I\\'m ready.');\r\n    }\r\n}",
                            "type": "typescript"
                        }, {
                            "order": 1,
                            "description": "<b>Not automatic</b>: A class decorated with @Application and with the parameter automatic=false, will not start automatically. To start you must create the instance.",
                            "code": "import { TheWayApplication, Application } from '@nihasoft\/the-way';\r\n\r\n@Application({\r\n    automatic: false\r\n})\r\nexport class Main extends TheWayApplication {\r\n\r\n    public start(): void {\r\n        console.log('I\\'m ready.');\r\n    }\r\n}\r\nnew Main();",
                            "type": "typescript"
                        }, {
                            "order": 2,
                            "description": "<b>Custom classes part 1</b>: A customized class",
                            "code": "import { ServerConfiguration, Configuration } from '@nihasoft\/the-way';\r\nimport { Observable } from 'rxjs';\r\n\r\n@Configuration(ServerConfiguration)\r\nexport class CustomServerConfiguration extends ServerConfiguration {\r\n    public configure(): Observable<boolean> {\r\n        this.port = 12345;\r\n        return this.start();\r\n    }\r\n}",
                            "type": "typescript"
                        }, {
                            "order": 3,
                            "description": "<b>Custom classes part 2</b>: A main class with custom class",
                            "code": "import { TheWayApplication, Application } from '@nihasoft\/the-way';\r\nimport { CustomServerConfiguration } from '.\/configuration\/server.configuration';\r\n\r\n@Application({\r\n    custom: [\r\n        CustomServerConfiguration\r\n    ]\r\n})\r\nexport class Main extends TheWayApplication {\r\n\r\n    public start(): void {\r\n        console.log('I\\'m ready.');\r\n    }\r\n}",
                            "type": "typescript"
                        }
                    ]
                }, {
                    "name": "configure",
                    "alias": "@Configure",
                    "description": "Is a decorator designed for configurations or things that need to started like database connections, servers and others. When you decorate a class with that you must extends the class AbstractConfiguration and implement the methods: configure(): Observable<boolean> and destroy(): Observable<boolean>, the method configure will be called at the init of the application and must stream true when the configuration/connection are done. The destroy method is called when the core will be destroyed and must stream true when all configurations/connectios are closed or destroyed. Also, when is provided in the decorator a class, this means, that class must be overridden for the current class decorated with @Configuration",
                    "guides": [
                        {
                            "order": 0,
                            "description": "An example",
                            "code": "import { ServerConfiguration, Configuration } from '@nihasoft\/the-way';\r\nimport { Observable } from 'rxjs';\r\n\r\n@Configuration(ServerConfiguration)\r\nexport class CustomServerConfiguration extends ServerConfiguration {\r\n    public configure(): Observable<boolean> {\r\n        this.port = 12345;\r\n        return this.start();\r\n    }\r\n}",
                            "type": "typescript"
                        }
                    ]
                }, {
                    "name": "service",
                    "alias": "@Service",
                    "description": "Is a decorator designed for services. When is provided in the decorator a class, this means, that class must be overridden for the current class decorated with @Service",
                    "guides": [
                        {
                            "order": 0,
                            "description": "An example",
                            "code": "import { Service } from '@nihasoft\/the-way';\r\n\r\n@Service()\r\nexport class FooService {\r\n    public print(): void {\r\n        console.log('BAR!');\r\n    }\r\n}",
                            "type": "typescript"
                        }
                    ]
                },  {
                    "name": "inject",
                    "alias": "@Inject",
                    "description": "This decorator is responsible to inject class into another class. When you use this decorator the injection is like a singleton(only one instance for all injections)",
                    "guides": [
                        {
                            "order": 0,
                            "description": "Injecting the service created above into the main",
                            "code": "import { TheWayApplication, Application, Inject } from '@nihasoft\/the-way';\r\nimport { CustomServerConfiguration } from '.\/configuration\/server.configuration';\r\nimport { FooService } from '.\/foo\/foo.service';\r\n\r\n@Application({\r\n    custom: [\r\n        CustomServerConfiguration\r\n    ]\r\n})\r\nexport class Main extends TheWayApplication {\r\n\r\n    @Inject() fooService: FooService;\r\n\r\n    public start(): void {\r\n        this.fooService.print();\r\n    }\r\n}",
                            "type": "typescript"
                        }
                    ]
                }
            ]
        }
    }
}